---
title: "Test dataset 2"
author: "Elizabeth Wenk, Sophie Yang"
format: html
editor: visual
---

## Overview

This is the second of five tutorials on adding datasets to your traits.build database.

Before you begin this tutorial, ensure you have installed traits.build, cloned the traits.build-template repository, and have successfully build a database from the datasets in `traits.build-template` . Instructions are available at \[XX\]{xx}

### Goals

-   Learn how to add substitutions for categorical trait values.

-   Learn how to merge in location data from a standalone spreadsheet.

-   Learn how to add custom R code to the metadata file.

-   Learn how to exclude observations.

### New Functions Introduced

-   metadata_add_substitution

-   metadata_add_substitutions_list

-   metadata_check_custom_R_code

-   metadata_exclude_observations

## Adding test_dataset_2

### Create a folder for the dataset

Begin by creating a folder titled `test_dataset_2` within the data folder.

Place the data.csv file for `test_dataset_2` in the folder.

Create a folder `raw` within the `test_dataset_2` for the `locations.csv` and `notes.txt` files.

### Use functions to create a metadata.yml file

#### Create a Metadata Template

To create the metadata template, run:

```{r eval=FALSE}
metadata_create_template("test_dataset_2")
```

As with `test_dataset_1` this function leads you through a series of menus requiring user input. Ensure you select:

data format: [**wide**]{style="color:red;"}\
taxon_name column: [**name_original**]{style="color:red;"}\
location_name column: [**site_TEXT**]{style="color:red;"}\
individual_id column: [**NA**]{style="color:red;"}\
collection_date column: [**NA**]{style="color:red;"}\

*Navigate to the dataset's folder and open the metadata.yml file in Visual Studio Code, to ensure information is added to the expected sections as you work through the tutorial.*

#### Propagate source information into the metadata.yml file

This dataset is from a published source and therefore the source information can be added with a single line of code:

```{r eval=FALSE}
metadata_add_source_doi(dataset_id = "test_dataset_2", doi = "10.1046/j.1365-2745.2000.00506.x")
```

confirm:

1.  the authors' names are formatted as `first name last name` or `first initial last name`\
2.  the article title is in sentence case\
3.  the page numbers are filled in as a range, separated by a double dash\

#### Add location details into the metadata.yml file

For this dataset, location data is provided as a standalone spreadsheet that should be archived in the raw data folder: "test_dataset_2\raw\locations.csv"

First read the location data provided into R:  
```{r eval=FALSE}
locations <-
  read_csv("data/test_dataset_2/raw/location_data.csv")
```

traits.build requires three fields to use a specific syntax:  

-   `latitude` must be in decimal degrees and the field name (column header) must be `latitude (deg)`   

-   `longitude` must be in decimal degrees and the field name (column header) must be `longitude (deg)`   

-   A general site description is document in the field `description`  


traits.build does not require that the labels for other location properties align across datasets, but it is best practice to use a controlled vocabulary, so database users can easily search across all datasets for information on a specific climate variable or soil nutrient content. For new databases or new location properties, any naming/labeling convention can be established.

To confirm you are using the correct syntax, check the terms already in use:

```{r eval=FALSE}
locations_properties <-
  traits.build_database$sites %>%
  distinct(location_property) %>%
  View()
```

Then rename your columns to match those in use:

```{r eval=FALSE}
locations <-
  locations %>%
    rename(
      `longitude (deg)` = long,  
      `latitude (deg)` = lat,  
      `description` = vegetation,  
      `elevation (m)` = elevation,  
      `precipitation, MAP (mm)` = MAP,  
      `soil P, total (mg/kg)` = `soil P`,  
      `soil N, total (ppm)` = `soil N`,  
      `geology (parent material)` = `parent material`  
    )
```

Now add the location information into the metadata file:

```{r eval=FALSE}
metadata_add_locations(dataset_id = "test_dataset_2", location_data = locations)
```

Ensure you select:

location_name: [**location**]{style="color:red;"}\
location_property columns: [**1 2 3 4 5 6 7 8**]{style="color:red;"}\

*Check the metadata.yml file to ensure the location information has been added as expected. If there is a problem, rerun the necessary code; this will overwrite what is present. You can also manually add additional properties if something is forgotten.*  

#### Add traits to the metadata.yml file

To select columns in the `data.csv` file that include trait data, run:  

```{r eval=FALSE}
metadata_add_traits(dataset_id = "test_dataset_2")
```

Select columns [**3 4 5 6**]{style="color:red;"}, as these contain trait data.

*After confirming that the skeletal traits section has been added to `metadata.yml` file, you must fill in all the `unknown` fields.*  

### Manual filling in of metadata

For this dataset, you will later use functions to add substitutions and exclude unwanted observations, but it is best to first fill in the information for contributors, the dataset, and the traits.

Now begin filling in the remaining metadata.yml fields manually.

These are all fields that contain the word `unknown`.

These include:\
*the `contributors` section*\
*the `description`, `basis_of_record`, `life_stage`, `sampling_strategy`, `original_file`, and `notes` under the `dataset` section*\
*details for each trait, including `unit_in`, `trait_name`, `entity_type`, `value_type`, `basis_of_record`, `replicates` and `methods`*

\#### Adding contributors

*The file "data/test_dataset_1/raw/test_dataset_1_notes.txt" indicates the main data_contributor for this study.*

*Fill in the remaining contributor information as described in the `test_dataset_1`[tutorial](https://XXX).*

\#### Filling in the missing dataset fields

*The file "data/test_dataset_1/raw/test_dataset_1_notes.txt" indicates how to fill in the `unknown` dataset fields for this study.*

\#### Filling in the missing details for each trait.

*The file "data/test_dataset_1/raw/test_dataset_1_notes.txt" indicates how to fill in the `unknown` trait fields for this study, but see below as well.*

\##### trait_name

*Remember, the `trait_name` must match a `trait_name` within the [traits dictionary](https://github.com/traitecoevo/traits.build-template/blob/master/config/traits.yml). For this example:*

`TRAIT Growth Form CATEGORICAL EP epiphyte (mistletoe) F fern G grass H herb S shrub T tree V vine` is plant_growth_form\
`TRAIT SLA UNITS mm2/g` is leaf_mass_per_area\
`TRAIT Leaf Size UNITS mm2` is leaf_area\
`TRAIT Leaf Dry Mass UNITS g` is leaf_dry_mass\

*You may notice that the second trait is provided by the author as `specific leaf area`, the inverse of `leaf mass per area`. The unit conversions algorithm inverts data read in as specific leaf area, converting it to leaf mass per area. (XXX- TODO - is it possible for this text to appear as a hover link above the word "NOTE" next to the actual trait; just continuing to think of how to reduce the main text.)*

The convention for filling in the remaining metadata fields is different for numeric versus categorical traits.

*For the three numeric traits, fill in:*

unit_in: [(use the units in column header)]{style="color:red;"}\
entity_type: [**population**]{style="color:red;"}\
value_type: [**mean**]{style="color:red;"}\
basis_of_value: [**measurement**]{style="color:red;"}\
replicates: [**5**]{style="color:red;"}\

*For the categorical trait, fill in:*

unit_in: [**.na**]{style="color:red;"}\
entity_type: [**species**]{style="color:red;"}\
value_type: [**mode**]{style="color:red;"}\
basis_of_value: [**expert_score**]{style="color:red;"}\
replicates: [**.na**]{style="color:red;"}\

-   Categorical traits do not have units or replicates, so these fields become `.na`.
-   The traits.build convention for a categorical trait is `value_type: mode`, indicating the recorded value is the most commonly observed trait value.
-   For most observations of categorical traits, the traits.build convention is that the `basis_of_value` is determined by an expert examining an individual, population or species, and is therefore an `expert_score`.

#### Additional steps

Once you are well-versed in adding datasets to a traits.build database you will know that there is additional information required in `metadata.yml`.

However, for this tutorial, let's begin by assuming we're finished adding dataset metadata and check for errors:

```{r eval=FALSE}
dataset_test("test_dataset_2")
```

Three items will fail: 1. There are unknown trait values for `plant_growth_form`\
2. There are values out of range for `leaf_dry_mass`\
3. There are duplicate entries detected for 11 observation_id's\

As indicated in the output messages, there is a \[troubleshooting vignette\](https://github.../vignettes/... to help solve these errors.\

For this tutorial however, keep reading:

##### Adding trait value substitutions

For categorical traits, only trait values that are indicated in the trait dictionary are recognised. This is an important harmonisation step, as it ensures the same trait value concept is mapped to the same trait value throughout the database.

However, researchers use countless synonyms, abbreviations and syntax to express an identical trait value. traits.build converts all input to lowercase, but all other substitutions must be specified in the dataset's `metadata.yml` file.

For this example you'll note that the `data.csv` file used individual letters to express 6 plant growth forms: t, s, h, f, g, ###.

Looking at the definition for `plant_growth_form` in the trait dictionary and the helpful column header provided by the contributor, you can deduce that `t` is for `tree`; `s` is for `shrub`, etc.

There are two ways to add substitutions into the `metadata.yml` file.

1.  You can map in individual substitutions for each of the errant trait values using:

```{r eval=FALSE}
metadata_add_substitution(dataset_id = "test_dataset_2", trait_name = "plant_growth_form", find = "t", replace = "tree")
```

*Now check the `metadata.yml` file and you'll note that a substitution has been added, to indicate the `t`'s are `tree`'s*

You would repeat this step for the remaining unknown trait values.

2.  If there are quite a few trait values that require replacements, it is easier to first create a table of the required substitutions, then add a column of substitutions in either R or Excel.

```{r eval=FALSE}
table <-
  my_database$excluded_data %>%
  filter(
    dataset_id == "test_dataset_2" &
      error == "Unsupported trait value"
  ) %>%
  distinct(dataset_id, trait_name, value) %>%
  rename(find = value)

# .. view your table to check the order of trait values ...

table <- table %>%
  mutate(replace = c("shrub", "tree", "herb", NA, "graminoid", "fern", "vine"))

metadata_add_substitutions_table(table, dataset_id = dataset_id, trait_name = trait_name, find = find, replace = replace)
```

*All required substitutions have been added to the `metadata.yml` file and if you were to rerun `dataset_test("test_dataset_2")` the error referring to `Unsupported trait values` should now have vanished.*

##### Replacing "placeholder characters" with NA's

The `Values out of range` error is triggered for numeric traits when the traits.build pipeline detects values that fall outside the range specified for the trait in the traits dictionary.

There are three common situations that lead to this error warning:\
1. Values are truly out of range, possibly due to human error or because a plant really was not performing as expected (i.e. not photosynthesising).\
2. Values appear to be out of range because of a "unit conversion issue" - that is, the dataset curator or the dataset contributor got the units wrong.\
This is fixed by working out the correct units and adjusting this in the traits section of the `metadata.yml` file.\
3. An dataset contributor has used a "dummy symbol" to indicate missing data, such as `0`, `x`, `missing`, etc. Truly missing data should be a blank cell - i.e. `NA`
